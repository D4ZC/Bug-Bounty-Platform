const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  // Información básica
  mendscanId: {
    type: String,
    unique: true,
    sparse: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true,
    trim: true
  },
  
  // Clasificación
  severity: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low'],
    required: true,
    index: true
  },
  category: {
    type: String,
    trim: true,
    default: ''
  },
  
  // Aplicación y equipo asignado
  application: {
    name: {
      type: String,
      required: true,
      trim: true
    },
    version: {
      type: String,
      trim: true,
      default: ''
    },
    url: {
      type: String,
      trim: true,
      default: ''
    }
  },
  assignedTeamId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Team',
    required: true,
    index: true
  },
  
  // Estado y resolución
  status: {
    type: String,
    enum: ['open', 'in_progress', 'resolved', 'closed'],
    default: 'open',
    index: true
  },
  resolvedBy: {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      default: null
    },
    teamId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Team',
      default: null
    },
    resolvedAt: {
      type: Date,
      default: null
    },
    resolutionTime: {
      type: Number, // en horas
      default: null
    }
  },
  
  // Puntuación
  points: {
    type: Number,
    required: true,
    min: 0
  },
  pointsAwarded: {
    type: Boolean,
    default: false
  },
  
  // Detalles técnicos
  cveId: {
    type: String,
    trim: true,
    default: null
  },
  cvssScore: {
    type: Number,
    min: 0,
    max: 10,
    default: null
  },
  affectedComponents: [{
    type: String,
    trim: true
  }],
  
  // Archivos y evidencia
  attachments: [{
    filename: {
      type: String,
      required: true
    },
    originalName: {
      type: String,
      required: true
    },
    mimeType: {
      type: String,
      required: true
    },
    size: {
      type: Number,
      required: true
    },
    uploadedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Comentarios y seguimiento
  comments: [{
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    content: {
      type: String,
      required: true,
      trim: true
    },
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Metadatos
  tags: [{
    type: String,
    trim: true
  }],
  priority: {
    type: Number,
    min: 1,
    max: 5,
    default: 3
  },
  
  // Fechas importantes
  discoveredAt: {
    type: Date,
    default: Date.now
  },
  dueDate: {
    type: Date,
    default: null
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Índices para optimizar consultas
vulnerabilitySchema.index({ status: 1, severity: 1 });
vulnerabilitySchema.index({ assignedTeamId: 1, status: 1 });
vulnerabilitySchema.index({ 'resolvedBy.userId': 1 });
vulnerabilitySchema.index({ 'resolvedBy.teamId': 1 });
vulnerabilitySchema.index({ discoveredAt: -1 });
vulnerabilitySchema.index({ dueDate: 1 });

// Virtuals
vulnerabilitySchema.virtual('isOverdue').get(function() {
  if (!this.dueDate || this.status === 'resolved' || this.status === 'closed') {
    return false;
  }
  return new Date() > this.dueDate;
});

vulnerabilitySchema.virtual('daysOpen').get(function() {
  const now = new Date();
  const created = new Date(this.createdAt);
  return Math.floor((now - created) / (1000 * 60 * 60 * 24));
});

vulnerabilitySchema.virtual('resolutionTimeHours').get(function() {
  if (!this.resolvedBy.resolvedAt || !this.createdAt) {
    return null;
  }
  const resolved = new Date(this.resolvedBy.resolvedAt);
  const created = new Date(this.createdAt);
  return Math.floor((resolved - created) / (1000 * 60 * 60));
});

// Métodos de instancia
vulnerabilitySchema.methods.resolve = function(userId, teamId) {
  this.status = 'resolved';
  this.resolvedBy = {
    userId,
    teamId,
    resolvedAt: new Date(),
    resolutionTime: this.resolutionTimeHours
  };
  return this.save();
};

vulnerabilitySchema.methods.close = function() {
  this.status = 'closed';
  return this.save();
};

vulnerabilitySchema.methods.addComment = function(userId, content) {
  this.comments.push({
    userId,
    content,
    createdAt: new Date()
  });
  return this.save();
};

vulnerabilitySchema.methods.addAttachment = function(fileData, uploadedBy) {
  this.attachments.push({
    filename: fileData.filename,
    originalName: fileData.originalname,
    mimeType: fileData.mimetype,
    size: fileData.size,
    uploadedBy,
    uploadedAt: new Date()
  });
  return this.save();
};

// Métodos estáticos
vulnerabilitySchema.statics.getBySeverity = function(severity) {
  return this.find({ severity, status: { $ne: 'closed' } })
    .populate('assignedTeamId', 'name')
    .populate('resolvedBy.userId', 'name avatar')
    .sort({ discoveredAt: -1 });
};

vulnerabilitySchema.statics.getByTeam = function(teamId, status = null) {
  const query = { assignedTeamId: teamId };
  if (status) {
    query.status = status;
  }
  
  return this.find(query)
    .populate('resolvedBy.userId', 'name avatar')
    .sort({ discoveredAt: -1 });
};

vulnerabilitySchema.statics.getResolvedByUser = function(userId) {
  return this.find({ 'resolvedBy.userId': userId })
    .populate('assignedTeamId', 'name')
    .sort({ 'resolvedBy.resolvedAt': -1 });
};

vulnerabilitySchema.statics.getOverdue = function() {
  return this.find({
    dueDate: { $lt: new Date() },
    status: { $in: ['open', 'in_progress'] }
  })
    .populate('assignedTeamId', 'name')
    .sort({ dueDate: 1 });
};

vulnerabilitySchema.statics.getStats = function() {
  return this.aggregate([
    {
      $group: {
        _id: '$severity',
        count: { $sum: 1 },
        resolved: {
          $sum: {
            $cond: [{ $eq: ['$status', 'resolved'] }, 1, 0]
          }
        },
        totalPoints: { $sum: '$points' },
        awardedPoints: {
          $sum: {
            $cond: ['$pointsAwarded', '$points', 0]
          }
        }
      }
    }
  ]);
};

// Middleware pre-save
vulnerabilitySchema.pre('save', function(next) {
  this.updatedAt = new Date();
  
  // Calcular puntos basados en severidad si no están definidos
  if (!this.points) {
    const pointMap = {
      critical: 100,
      high: 75,
      medium: 50,
      low: 25
    };
    this.points = pointMap[this.severity] || 25;
  }
  
  next();
});

module.exports = mongoose.model('Vulnerability', vulnerabilitySchema); 